/*****************************************************************************

    SVM classification 
  
  NB: inference only, no training
  SVM model data is stored in smv.h (generated by SVMpy2c.py)

****************************************************************/

#include <math.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include "svm_model.h"
#include "svm.h"

uint32_t exp_custom(feature_dist_data_t x, int shift);
feature_data_t scale_data_V(feature_data_t x, int index);
feature_data_t* feature_select_V(feature_data_t* x, feature_data_t* feature_vector); 
feature_data_t scale_data_S(feature_data_t x, int index);
feature_data_t* feature_select_S(feature_data_t* x, feature_data_t* feature_vector); 

// Classifies data point x using the model in svm.h
int svm_predict( int16_t* x)
	{
    int i = 0;
    int out = 0; 
		int k;
    int f;
    
    // --- NS v V --- //
    feature_data_t* feature_vector_V;
    feature_vector_V = (feature_data_t*) malloc(n_feat_V*sizeof(feature_data_t));
    
    // Select features
    feature_vector_V = feature_select_V(x, feature_vector_V); 
    
    // Scale
    for(i=0; i<n_feat_V; i++){
      feature_vector_V[i] = scale_data_V(feature_vector_V[i],i);
    }
    
    // Compute SVM
		decision_data_t sum_V = 0;

		for(k=0;k<n_sv_V;k++) 
    {
      feature_dist_data_t dist = 0;  
      for(f=0;f<n_feat_V;f++)
      {
        feature_dist_data_t diff = feature_vector_V[f] - sv_V[k][f]; 
        dist += (diff*diff)>>feature_acc_shift;
      }
      sum_V += ((int64_t)sv_coef_V[k] * exp_custom(dist/gam_inv_V,(feature_shift<<1)-feature_acc_shift))>>kernel_acc_shift;
    }
    sum_V += rho_V;
    
    // --- N v S --- //
    feature_data_t* feature_vector_S;
    feature_vector_S = (feature_data_t*) malloc(n_feat_S*sizeof(feature_data_t));
    
    // Select features
    feature_vector_S = feature_select_S(x, feature_vector_S); 
    
    
    // Scale
    for(i=0; i<n_feat_S; i++){
      feature_vector_S[i] = scale_data_S(feature_vector_S[i],i);
    }
    
    // Compute SVM    
		decision_data_t sum_S = 0;
        
		for(k=0;k<n_sv_S;k++) 
    {
      feature_dist_data_t dist = 0;  
      for(f=0;f<n_feat_S;f++)
      {
        feature_dist_data_t diff = feature_vector_S[f] - sv_S[k][f]; 
        dist += (diff*diff)>>feature_acc_shift;
      }
      sum_S += ((int64_t)sv_coef_S[k] * exp_custom(dist/gam_inv_S,(feature_shift<<1)-feature_acc_shift))>>kernel_acc_shift;
    }
    sum_S += rho_S;
    
    if(sum_V > 0)
			out = 3;
		else{
      if(sum_S>0)
        out = 1;
      else
        out = 2;
    }
    
    free(feature_vector_S);
    free(feature_vector_V);
		return out;
	}

uint32_t exp_custom(feature_dist_data_t x, int input_shift){
  
  // Approximates exp function by successive multiplication (positive input only)
  // Start at 1
  // If i-th bit of x is 1, multiplies by exp(2^i) (stored in exp_ai vector)
  
  // Input is fixed point with "input_shift" decimal bits
  // Output is fixed point with "exp_shift" decimal bits
  
  int index = (-input_shift<exp_ai_min)?exp_ai_min:-input_shift; // Iterations start at highest of input decimal resolution or factor resolution
  uint32_t val = 1U<<exp_shift; // Start at 1 (fixed point)
  feature_dist_data_t mask = 1U<<(index+input_shift); // Mask to select bits from input
  if((x>>(input_shift+exp_ai_max))>0){ // If value is high (above array range), result is approximated to 0
    val = 0;
  }else{
    for(;index<=exp_ai_max;index++){ // For each bit of input
      if(mask & x){ // Check if bit is 1
        val = (val*exp_ai[index-exp_ai_min])>>exp_shift; // Multiply and shift back to fixed point position (multiplication of 2 fixed-point with exp_shift decimal bits)
      }
      mask = mask<<1;
    }
  }
  return val;
}

feature_data_t scale_data_V(feature_data_t x, int index){
  feature_data_t output = ((x-scale_mean_V[index])*scale_std_V[index])>>scale_shift;
  return output;
}

feature_data_t scale_data_S(feature_data_t x, int index){
  feature_data_t output = ((x-scale_mean_S[index])*scale_std_S[index])>>scale_shift;
  return output;
}

feature_data_t* feature_select_V(feature_data_t* x, feature_data_t* feature_vector){
  int i = 0;
  for(i=0;i<n_feat_V;i++){
    feature_vector[i] = x[feature_select_idx_V[i]];
  }
  return feature_vector;
}

feature_data_t* feature_select_S(feature_data_t* x, feature_data_t* feature_vector){
  int i = 0;
  for(i=0;i<n_feat_S;i++){
    feature_vector[i] = x[feature_select_idx_S[i]];
  }
  return feature_vector;
}